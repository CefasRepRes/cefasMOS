% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/UKF.R
\name{UKF}
\alias{UKF}
\title{Unscented Kalman filter (UKF)}
\usage{
UKF(
  y,
  mod,
  GGfunction,
  FFfunction,
  kappa = 0,
  sqrtMethod = "Cholesky",
  logLik = FALSE,
  simplify = FALSE
)
}
\arguments{
\item{y}{data. The data can be a vector (one-dimensional measurements / # univariate time series)
or a matrix (multidimensional measurements /
multivariate time series). In the matrix case, each of the columns contains
the measurements on a single dimension (or, similarly, a single \link{univariate}
time series).
Missing values (NA's) are allowed.}

\item{mod}{a list with the following components:
m0 (initial state estimates),
C0 (inital state covariances),
V (measurement noise),
W (process noise).}

\item{GGfunction}{a function with arguments x and k. The GGfunction specifies the
state transition function. The transition function is usually denoted as
f(x\link{k}, u\link{k}), where x are the states estimates and u the control input at
time step k.}

\item{FFfunction}{a function with arguments x and k. The FFfunction specifies the
observation/measurement function. The measurement function is usually denoted as h(x\link{k}).}

\item{kappa}{a tuning parameter for the Sigma points.}

\item{sqrtMethod}{specifies the method that will be used for computing the matrix,
square root. The method is either "Cholesky" (=Cholesky decomposition, the default) or "svd" (=singular value decomposition).}

\item{logLik}{if TRUE, then return the negative loglikelihood of the specified model.}

\item{simplify}{if TRUE, then do not include the data (=y) in the output.}
}
\value{
list containing,
m = the filtered state estimates
C = the filtered state covariance
}
\description{
This function implements the Unscented Kalman Filter (UKF) as described
by Julier and Uhlmann in their 1997 paper "A New Extension of the Kalman Filter to Nonlinear Systems".
}
\details{
Note that this UKF assumes (time invariant) additive noise.

It is possible to include control input in the GGfunction.
As an example, let us assume that there are two states (x1 and x2) and that
we have 70 time steps at which we want to obtain state estimates. At each of
these 70 time steps there will be (external) control input.

We may specify an arbitrary GGfunction with control input as follows:
\code{
 GGfunction <- function (x, k){
 x1 <- x[1]; x2 <- x[2]
 c(2*x1 + 1*x2 - 4,
   3*x2 - 1*x2 - 2)}}
where, at each time step, the control input for the first state equation
is -4, and the control input for the second state equation -2.

Alternatively, we may store the control input for the two state equations
at each of the 70 time steps in a 70x2 matrix.
Subsequently, we specify the GGfunction as:
GGfunction <- function (x, k){
\code{
 x1 <- x[1]; x2 <- x[2]
 c(2*x1 + 1*x2 - u[k,1],
   3*x2 - 1*x2 - u[k,2])}}
where we have stored the control input at each of the 70 time steps
in a matrix called u.

Note that the latter specification of the GGfunction is useful when the control
input is known to vary over time.
}
\references{
Julier & Uhlmann, 1997, A New Extension of the Kalman Filter to Nonlinear Systems
}
\author{
Stefan Gelissen (info@datall-analyse.nl)
}
